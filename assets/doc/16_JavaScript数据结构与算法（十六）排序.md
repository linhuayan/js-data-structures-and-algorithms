# JavaScript 数据结构与算法（十六）  
## 认识排序算法  
排序算法是笔试中经常出现的。  
- 排序算法的种类：冒泡排序、选择排序、插入排序、归并排序、计数排序（counting sort）、基数排序（radix sort）、希尔排序、堆排序、桶排序。  
  - 简单排序：冒泡排序-选择排序-插入排序
  - 高级排序：希尔排序-快速排序

- 一旦我们将数据放置在某个数据结构中存储起来后（比如数组），就可能根据需求对数据进行不同方式的排序
  - 比如对姓名按字母排序
  - 对学生按年龄排序
  - 对商品按照价格排序
  - 对城市按照面积或者人口数量排序  

## 如何排序？  
- 由于排序非常重要而且可能非常耗时，所以它已经成为一个计算机科学中广泛研究的课题。  
  - 而且人们已经研究出一套成熟的方案来实现排序
  - 因此，幸运的是你并不需要发明某种排序算法，而是站在巨人的肩膀上即可。

- 如何排序
  - 需求：对一组身高不等的10个人进行排序

- 人来排序：  
  - 如果是人来排序事情会非常简单，因为人只要扫过去一眼就能看出来谁最高谁最低。  
  - 然后让最低（或者最高）的站在前面，其他人依次后移。  
  - 按照这样的方法，依次类推就可以了。  
  
- 人排序的特点：  
  - 可以统筹全局，直接获取到最高或者最低的结果。  
  - 不需要考虑空间的问题，因为通常情况下都有足够的空间来相互推嚷。  

- 计算机来排序： 
  - 计算机有些笨拙，它只能执行指令，所以没办法一眼扫过去。
  - 计算机也很聪明，只要你写出了正确的指令，可以让它帮你做无数次类似的事情而不用担心出现错误。  
  - 并且计算机排序也无需担心数据量的大小。  
  - （想象一样，让人排序10000个，甚至更大的数据项你还能一眼扫过去吗？ ）
  - 人在排序时不一定要固定特有的空间，他们可以相互推推嚷嚷就腾出了位置，还能互相前后站立
  - 但是计算机必须有严密的逻辑和特定的指令。  

- 计算机排序的特点：  
  - 计算机不能像人一样，一眼扫过去这样通览所有的数据。  
  - 它只能根据计算机的比较操作原理，在同一时间对两个队员进行比较。
  - 在人类看来很简单的事情，计算机的算法却不能看到全景。  
  - 因此，它只能一步步解决具体问题和遵循一些简单的规则。  

## 封装列表  
- 在开始排序前，我们先来创建一个列表封装我们的数据项。  
```js
// 封装ArrayList
function ArrayList() {
  this.array = [];
   
   ArrayList.prototype.insert = function (item) {
    this.array.push(item)
   }

   ArrayList.prototype.toString = function () {
    return this.array.join('-');
   }
}

// 初始化数据项
var list = new ArrayList()

list.insert(3)
list.insert(6)
list.insert(4)
list.insert(2)
list.insert(11)
list.insert(10)
list.insert(5)

alert(list)
```

## 冒泡排序  
- 冒泡排序算法相对其他排序运行效率较低，但是在概念上它是排序算法中最简单的。  
  - 因此，冒泡排序是在刚开始学习排序时，最适合学习的一种排序方式  
- 冒泡排序的思路：  
  - 对未排序的各元素从头到尾依次比较相邻的两个元素大小关系
  - 如果左边的队员高，则量队员交换位置
  - 向右移动一个位置，比较下面两个队员
  - 当走到最右端时，最高的队员一定被放在了最右边
  - 按照这个思路，从最左端重新开始，这次走到倒数第二个位置的队员即可。  
  - 依次类推，就可以将数据排序完成。  

### 冒泡排序代码思路分析  
- 第一次找出最高人放在最后，我们需要两个两个数据项进行比较，那么这个应该是一个循环操作。  
- 第二次将次高的人找到放在倒数第二个位置，也是两个比较，只是不要和最后一个比较（少了一次），但是前面的两个两个比较也是一个循环操作。  
- 第三次...第四次...
- 有发现规律吗？这应该是一个循环中嵌套循环，并且被嵌套的循环次数越来越少的。

## 希尔排序
### 希尔排序的实现  
- 代码解析
- 代码序号1：获取数组的长度
- 代码序号2：计算第一次的间隔，我们按照希尔提出的间隔实现。
- 代码序号3：增量不断变小，大于0就继续改变增量
- 代码序号4：实际上就是实现了插入排序
  - 代码序号4.1：保存临时变量，j位置从i开始，保存该位置的值到变量temp中
  - 代码序号4.2：内层循环，`j>gap-1`并且temp大于`this.array[j-gap]`，那么就进行复制。  
  - 代码序号4.3：将j位置设置为变量temp。
- 代码序号5：每次while循环后都重新计算新的间隔。